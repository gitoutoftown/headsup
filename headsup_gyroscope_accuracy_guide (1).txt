# HeadsUp: Gyroscope Tracking Accuracy Implementation Guide

## Executive Summary

This document provides implementation guidance for achieving 85-90% posture tracking accuracy using device motion sensors. The key insight: **Use CMDeviceMotion (Apple's sensor fusion) INSTEAD OF raw gyroscope data** for significantly better accuracy with minimal extra effort.

---

## Critical Decision: CMDeviceMotion vs Raw Gyroscope

### RECOMMENDATION: Use CMDeviceMotion (REPLACE raw gyroscope)

**What is CMDeviceMotion?**
- Apple's CoreMotion framework combines multiple sensors automatically:
  - Gyroscope (rotation rate)
  - Accelerometer (gravity direction)
  - Magnetometer (compass for absolute reference)
- Pre-processed, fused sensor data
- More accurate than raw gyroscope alone
- Handles sensor drift and calibration internally

**Why CMDeviceMotion is better:**
- ‚úÖ More accurate orientation (accounts for gravity)
- ‚úÖ Less drift over time (auto-calibrates)
- ‚úÖ Easier to use (fewer calculations needed)
- ‚úÖ Better battery efficiency (optimized by Apple)
- ‚úÖ Handles edge cases (sensor errors, calibration)

**Why NOT to use raw gyroscope:**
- ‚ùå Gyroscope only measures rotation rate (not absolute orientation)
- ‚ùå Accumulates drift over long sessions
- ‚ùå Doesn't account for gravity direction
- ‚ùå Requires manual sensor fusion with accelerometer
- ‚ùå More complex filtering needed

### Implementation Approach

**For Flutter + iOS:**

1. **Don't use:** `sensors_plus` package for raw gyroscope
2. **Do use:** Platform channel to access native iOS CoreMotion
3. **Access:** `CMDeviceMotion` object via `CMMotionManager`
4. **Get:** `attitude` property for device orientation

**Flutter will need:**
- Platform channel (MethodChannel) to call native iOS code
- Native iOS Swift/Objective-C code to access CMMotionManager
- Return attitude data (pitch, roll, yaw) to Flutter side

---

## Implementation Roadmap

### Phase 1: Core Tracking (Weeks 3-4) - MUST HAVE

#### 1.1 Use CMDeviceMotion for Sensor Data

**Objective:** Replace raw gyroscope with Apple's fused sensor data

**iOS Native Implementation:**

**What to implement:**
- Create MethodChannel in Flutter
- Implement native iOS code using CMMotionManager
- Start device motion updates when session begins
- Stream attitude data (pitch, roll, yaw) back to Flutter
- Stop updates when session ends

**Data to retrieve from CMDeviceMotion:**
```
pitch: Rotation around X-axis (forward/backward tilt)
roll: Rotation around Y-axis (left/right tilt)  
yaw: Rotation around Z-axis (compass direction - optional)
```

**Update frequency:**
- Set update interval to 0.2 seconds (5 Hz / every 5 seconds)
- Balance between accuracy and battery life
- Don't sample faster than needed

**Error handling:**
- Check if device motion is available
- Handle permission issues
- Detect sensor failures gracefully

#### 1.2 Calculate 3D Tilt Angle

**Objective:** Compute accurate phone tilt from vertical using pitch and roll

**Algorithm:**

**Convert radians to degrees (iOS gives radians):**
```
pitch_degrees = pitch_radians √ó (180 / œÄ)
roll_degrees = roll_radians √ó (180 / œÄ)
```

**Calculate combined tilt angle:**
```
tilt_angle = sqrt(pitch_degrees¬≤ + roll_degrees¬≤)
```

**Interpretation:**
- 0¬∞ = Phone perfectly vertical (standing upright)
- 10¬∞ = Excellent posture (phone at ideal eye level)
- 20¬∞ = Good posture (phone at eye level, comfortable tilt)
- 40¬∞ = Okay posture (acceptable but room for improvement)
- 65¬∞ = Bad posture (phone getting low, neck bending)
- 90¬∞ = Phone horizontal (lying flat or severe hunch)

**Why this works:**
- Captures tilt in any direction (not just forward/back)
- Accounts for users holding phone at angles
- More accurate than pitch-only measurement
- Mathematical representation of "distance from vertical"

**Posture Zones (5-Tier System):**

**Excellent (0-10¬∞):**
- Score: 95-100 points
- Character: Perfect upright posture, standing tall
- Meaning: Phone at ideal height, minimal neck strain
- Feedback: "Excellent posture! üåü"

**Good (11-20¬∞):**
- Score: 80-94 points
- Character: Straight, healthy posture
- Meaning: Great posture, sustainable for long sessions
- Feedback: "Good posture"

**Okay (21-40¬∞):**
- Score: 55-79 points
- Character: Slight forward curve beginning
- Meaning: Acceptable range, room for improvement
- Feedback: "Okay - try raising phone a bit"

**Bad (41-65¬∞):**
- Score: 25-54 points
- Character: Noticeable hunch, head forward
- Meaning: Poor posture, neck strain building
- Feedback: "Bad posture - please adjust"
- Alert: Gentle haptic after 20 minutes sustained

**Poor (66¬∞+):**
- Score: 0-24 points
- Character: Severe hunch, significant forward head
- Meaning: Severe poor posture, high neck strain
- Feedback: "Poor posture - raise phone now!"
- Alert: Immediate haptic, visual warning

**Smooth Scoring Algorithm:**
```
Calculate score based on angle with gradual transitions:

if angle <= 10:
    score = 95 + (10 - angle) * 0.5  // 100 at 0¬∞, 95 at 10¬∞
    
elif angle <= 20:
    score = 80 + (20 - angle) * 1.5  // 94 at 11¬∞, 80 at 20¬∞
    
elif angle <= 40:
    score = 55 + (40 - angle) * 1.25  // 79 at 21¬∞, 55 at 40¬∞
    
elif angle <= 65:
    score = 25 + (65 - angle) * 1.2  // 54 at 41¬∞, 25 at 65¬∞
    
else:
    score = max(0, 25 - (angle - 65) * 1.0)  // 24 at 66¬∞, 0 at 90¬∞+
```

**Benefits of 5-tier graduated system:**
- No hard cutoffs (smooth transitions between zones)
- Small improvements always rewarded (39¬∞ ‚Üí 38¬∞ shows progress)
- More nuanced feedback (not just "good" or "bad")
- Encourages excellence (0-10¬∞) without punishing okay (21-40¬∞)
- Only severe angles (66¬∞+) trigger interruption
- Meaning: Phone getting low, neck bending forward
- Character state: Noticeable forward curve, slight hunch
- Feedback: "Bad posture - try raising phone"
#### 1.3 Apply Moving Average Filter

**Objective:** Smooth out sensor noise and hand tremors

**Implementation:**

**Keep circular buffer of recent readings:**
```
buffer_size = 5 readings
buffer = [angle1, angle2, angle3, angle4, angle5]
```

**Calculate smoothed angle:**
```
smoothed_angle = (angle1 + angle2 + angle3 + angle4 + angle5) / 5
```

**Update buffer:**
- Add new reading to end
- Remove oldest reading from beginning
- Maintain fixed size (5 readings)

**Benefits:**
- Reduces jitter from hand movements
- Provides stable reading for UI
- Minimal lag (only 5-reading delay at 5Hz = 1 second)

**When to reset buffer:**
- Session starts (clear old data)
- After auto-pause/resume
- After calibration

#### 1.4 Context Detection - Basic

**Objective:** Detect when NOT to track and auto-pause

**Scenarios to detect:**

**A. Phone Face-Down:**
```
Detection: pitch ‚âà 180¬∞ or roll ‚âà 180¬∞
Action: Auto-pause after 2 minutes face-down
Reason: Phone on table, not in use
```

**B. Phone Face-Up Flat:**
```
Detection: pitch ‚âà 0¬∞ AND roll ‚âà 0¬∞ for >5 minutes
Action: Prompt user "Still tracking?"
Reason: Phone on desk, passive use
```

**C. Landscape Orientation:**
```
Detection: roll ‚âà 90¬∞ or roll ‚âà -90¬∞
Action: Use different thresholds (add 20¬∞ to all thresholds)
Reason: Watching videos has different ergonomics
```

**D. Device Charging + Stationary:**
```
Detection: Battery state = charging AND minimal movement for >5 min
Action: Auto-pause
Reason: Phone plugged in on desk/nightstand
```

**Implementation strategy:**
- Check these conditions every 30 seconds
- Don't check every sensor reading (too aggressive)
- Show user-friendly pause reason in UI
- Allow manual resume

#### 1.5 Outlier Rejection

**Objective:** Filter out impossible or erroneous readings

**Rules to implement:**

**Rule 1: Instant change threshold**
```
If |current_angle - previous_angle| > 30¬∞ AND time_diff < 1 second:
    ‚Üí Reject reading, keep previous value
    ‚Üí Likely: dropped phone, gesture, sensor glitch
```

**Rule 2: Physically impossible angles**
```
If tilt_angle > 95¬∞:
    ‚Üí Reject reading
    ‚Üí Likely: phone upside down or sensor error
```

**Rule 3: Rapid oscillation**
```
If angle changes direction >5 times in 10 seconds:
    ‚Üí Reject all readings in this period
    ‚Üí Likely: shaking phone, walking, unstable grip
```

**Logging:**
- Track rejection count
- If >20% of readings rejected in session ‚Üí warn user of sensor issues

---

### Phase 2: User Education & Polish (Weeks 5-6) - SHOULD HAVE

#### 2.1 Universal Posture Zones (No Calibration)

**Objective:** Use research-based standard zones for all users

**Fixed Universal Zones:**
```
Excellent: 0-10¬∞
Good: 11-20¬∞
Okay: 21-40¬∞
Bad: 41-65¬∞
Poor: 66¬∞+

These zones are the same for ALL users.
No personal calibration or adjustment.
```

**Why universal zones:**
- Social features remain fair (everyone on same standard)
- Leaderboards and challenges are meaningful
- Clear health standard to aspire to
- Simpler implementation (no calibration data to store/manage)
- Educates users on proper posture (objective standard)
- Phone angle normalizes for height (tall/short doesn't matter)

**Onboarding Education (Not Calibration):**
```
Screen 1: "Hold phone at eye level"
- Show live angle reading
- When user achieves 10-15¬∞: "Perfect! This is Excellent posture"
- This teaches proper posture, doesn't calibrate

Screen 2: "HeadsUp tracks 5 posture zones"
- Show all 5 character states with labels
- Explain point system
- User learns the standard, doesn't set personal baseline
```

**Storage:**
- No calibration data needed
- Zones are hardcoded constants
- Simpler database schema
- Use defaults if calibration skipped:
  - Excellent: 0-10¬∞
  - Good: 11-20¬∞
  - Okay: 21-40¬∞
  - Bad: 41-65¬∞
  - Poor: 66¬∞+

#### 2.2 Temporal Smoothing (Ignore Brief Angles)

**Objective:** Only count sustained poor posture, not momentary positions

**Algorithm:**

**Track angle duration:**
```
current_zone = determine_zone(current_angle)  // Excellent/Good/Okay/Bad/Poor

If current_zone is Bad or Poor:
    bad_posture_timer += elapsed_time
    
    If bad_posture_timer >= 5 seconds:
        ‚Üí Count toward zone time totals
        ‚Üí Track for scoring
    Else:
        ‚Üí Ignore (temporary position, likely gesture)
        
If current_zone improves (Okay/Good/Excellent):
    bad_posture_timer = 0  // Reset
    ‚Üí Count immediately (reward good posture right away)
```
```

**Benefits:**
- Brief glances down don't hurt score
- User can check notifications without penalty
- Only sustained hunching counts
- More accurate representation of habit

**Adjustable threshold:**
- 5 seconds for MVP
- Let advanced users adjust (3-10 seconds range)
- Stricter = 3 seconds, More lenient = 10 seconds

#### 2.3 Point-Based Scoring System

**Objective:** Reward excellence, provide gamification foundation

**Points per minute by zone:**
```
Excellent (0-10¬∞):   +5 points/minute
Good (11-20¬∞):       +3 points/minute
Okay (21-40¬∞):       +1 point/minute
Bad (41-65¬∞):         0 points/minute
Poor (66¬∞+):          0 points/minute
```

**Implementation:**
```
For each minute of session:
    current_zone = determine_zone(current_angle)
    
    if current_zone == Excellent:
        points_this_minute = 5
    elif current_zone == Good:
        points_this_minute = 3
    elif current_zone == Okay:
        points_this_minute = 1
    else:  // Bad or Poor
        points_this_minute = 0
    
    total_points += points_this_minute
    zone_minutes[current_zone] += 1
```

**Session Score Calculation (0-100):**
```
Per-minute score values:
- Excellent minute: 100
- Good minute: 75
- Okay minute: 40
- Bad minute: 10
- Poor minute: 0

Session Score = Sum of all minute scores / Total minutes

Example:
10 min Excellent (100 each) = 1000
20 min Good (75 each) = 1500
20 min Okay (40 each) = 800
10 min Bad (10 each) = 100
Total: 3400 / 60 minutes = 56.7 score
```

**Display to User:**
```
Primary metric: Total points earned (1,847 POINTS)
Secondary metric: Session score (71/100)
Breakdown: Show minutes and points per zone
```

**Benefits:**
- Incentivizes striving for Excellent vs settling for Okay
- No negative points (zero floor, not punishing)
- Gamification-ready (goals, achievements, challenges)
- Fair social competition (everyone on same point system)
- Longer sessions naturally earn more points

#### 2.4 Gravity Vector Fusion (Already Handled by CMDeviceMotion)

**Note:** If using CMDeviceMotion, this is automatic!

**What CMDeviceMotion does internally:**
- Fuses gyroscope rotation rate with accelerometer gravity vector
- Provides absolute orientation relative to Earth
- Handles sensor drift correction
- More accurate than manual implementation

**If NOT using CMDeviceMotion (not recommended):**
- Would need to manually combine gyroscope + accelerometer
- Complex quaternion math required
- Prone to errors and drift
- Don't do this - use CMDeviceMotion instead

---

### Phase 3: Advanced Features (Weeks 7-8) - NICE TO HAVE

#### 3.1 Adaptive Thresholds (Percentile-Based)

**Objective:** Automatically adjust to user's natural patterns

**Algorithm:**

**After 7 days of data collection:**
```
Collect all angle readings from user's history
Sort angles from smallest to largest

good_threshold = 25th percentile angle
fair_threshold = 50th percentile angle (median)
poor_threshold = 75th percentile angle

Example with user's data:
- 25th percentile: 40¬∞ ‚Üí Good posture
- 50th percentile: 55¬∞ ‚Üí Fair posture  
- 75th percentile: 70¬∞ ‚Üí Poor posture
```

**Benefits:**
- Adapts to individual usage patterns
- Accounts for different phone usage contexts
- No manual calibration needed
- Self-optimizing over time

**Implementation:**
- Run calculation weekly
- Gradually transition thresholds (don't shock-change)
- Show user: "Your thresholds were updated based on your patterns"
- Allow manual override

#### 3.2 Session Trajectory Analysis

**Objective:** Track how posture changes over session duration

**Data to capture:**
```
Every 5 minutes of session, record:
- Average angle in this 5-min window
- Percentage good posture in this window
- Trend direction (improving/degrading)
```

**Analysis after session:**
```
Calculate:
- Starting posture quality (first 10 minutes)
- Ending posture quality (last 10 minutes)
- Degradation rate: (end_quality - start_quality) / duration
- Best 5-minute window
- Worst 5-minute window
```

**Insights to show user:**
```
"Your posture was excellent for the first hour, then declined"
"You maintained consistent posture throughout - great job!"
"Your posture degrades most between 2-3pm"
```

**Use for alerts:**
- If degradation rate exceeds threshold ‚Üí earlier alert
- If posture consistent ‚Üí reduce alert frequency

#### 3.3 Dynamic Baseline Adjustment

**Objective:** Account for natural fatigue during long sessions

**Problem:**
- Fresh morning posture: 35¬∞ average
- Tired afternoon posture: 50¬∞ average
- Shouldn't penalize natural fatigue

**Solution - Gradual baseline drift:**

**Every 30 minutes:**
```
current_30min_average = mean angle of last 30 minutes

If current_30min_average > baseline + 10¬∞:
    // User's posture has degraded
    baseline = baseline + 2¬∞  // Gradual adjustment
    // Don't fully jump to new baseline
    
If current_30min_average < baseline - 10¬∞:
    // User improved posture
    baseline = baseline - 2¬∞
```

**Limits:**
```
Don't drift more than ¬±15¬∞ from original calibration
If drift exceeds 15¬∞ ‚Üí suggest recalibration
Reset baseline each morning (6 AM)
```

**Benefits:**
- Tracks relative degradation, not absolute
- More encouraging scoring
- Reflects realistic human behavior

---

## Accuracy Expectations by Phase

**Baseline (raw gyroscope, no filtering):**
- ~70% accuracy
- Many false positives/negatives
- Jittery, unreliable

**Phase 1 Complete (CMDeviceMotion + filtering + context):**
- ~85% accuracy (+15% improvement)
- Smooth, stable readings
- Handles most edge cases
- **Sufficient for MVP launch**

**Phase 2 Complete (+ personalization):**
- ~90% accuracy (+5% improvement)
- Adapted to individual users
- Fewer false alerts
- Better user experience

**Phase 3 Complete (+ adaptive features):**
- ~92% accuracy (+2% improvement)
- Self-optimizing
- Context-aware
- Diminishing returns beyond this

**Note:** Going beyond 92% requires camera/AirPods (not worth the trade-offs for MVP)

---

## Implementation Checklist

### Week 3-4: Core Tracking
- [ ] Create Flutter MethodChannel for native iOS communication
- [ ] Implement iOS native code to access CMMotionManager
- [ ] Start/stop device motion updates with HealthKit workout
- [ ] Stream pitch and roll data to Flutter
- [ ] Calculate 3D tilt angle (sqrt of pitch¬≤ + roll¬≤)
- [ ] Implement 5-point moving average filter
- [ ] Implement universal zone detection (5 zones: 0-10¬∞, 11-20¬∞, 21-40¬∞, 41-65¬∞, 66¬∞+)
- [ ] Detect face-down orientation
- [ ] Detect landscape orientation
- [ ] Reject outlier readings (>30¬∞ instant change)
- [ ] Test on physical device (simulators don't have motion sensors)
- [ ] Measure battery impact (should be <5% per hour)

### Week 5-6: Scoring & Polish
- [ ] Implement point-based scoring system
  - [ ] Track time in each zone per session
  - [ ] Calculate points: Excellent +5, Good +3, Okay +1, Bad/Poor 0
  - [ ] Calculate session score (0-100)
  - [ ] Store points and zone times in database
- [ ] Build posture education UI in onboarding (no calibration)
- [ ] Show live angle during onboarding education
- [ ] Implement temporal smoothing (5-second threshold for Bad/Poor)
- [ ] Only count sustained poor posture
- [ ] Display points and score on home screen
- [ ] Display zone breakdown on session summary
- [ ] Test scoring system accuracy

### Week 7-8: Polish (If Time Allows)
- [ ] Track 5-minute session windows for trajectory analysis
- [ ] Calculate session trajectory metrics
- [ ] Show insights on session summary screen
- [ ] Implement zone-specific haptic patterns
- [ ] Add "time in zone" visualizations

---

## Testing Strategy

### Accuracy Testing

**Test scenarios:**
1. **Sitting at desk, phone in hand**
   - Expected: 30-50¬∞ angle (good posture)
   - Track for 15 minutes, verify stable readings

2. **Lying down, phone overhead**
   - Expected: 0-20¬∞ angle (phone vertical)
   - Should show good posture, not poor

3. **Hunched scrolling**
   - Expected: 60-80¬∞ angle (poor posture)
   - Should trigger alert after 30 minutes

4. **Walking with phone**
   - Expected: Fluctuating angles
   - Should auto-pause or smooth out readings

5. **Phone on table face-up**
   - Expected: 0¬∞ tilt
   - Should auto-pause after 5 minutes

6. **Video watching (landscape)**
   - Expected: 90¬∞ roll angle
   - Should use landscape thresholds

**Validation:**
- Compare reported angles with manual measurements (protractor app)
- Target: ¬±5¬∞ accuracy
- False positive rate <10%
- False negative rate <10%

### Battery Testing

**Test protocol:**
1. Fully charge device
2. Start tracking session
3. Use phone normally for 2 hours
4. Check battery percentage
5. Calculate drain rate

**Acceptance criteria:**
- <10% battery drain per 2 hours
- <5% per hour is ideal
- If >10%, optimize sampling rate

### Performance Testing

**Metrics to measure:**
- Sensor reading processing time (<10ms)
- UI update latency (<100ms)
- Memory usage (<50MB)
- No dropped frames during tracking

---

## Common Pitfalls & Solutions

### Pitfall 1: Gyroscope Drift
**Problem:** Raw gyroscope accumulates error over time
**Solution:** Use CMDeviceMotion (includes auto-calibration)

### Pitfall 2: Noisy Readings
**Problem:** Jittery angle values make UI unstable
**Solution:** Moving average filter + outlier rejection

### Pitfall 3: False Positives While Walking
**Problem:** Walking creates fluctuating angles
**Solution:** Detect sustained poor posture (>5 seconds)

### Pitfall 4: Wrong Thresholds for User
**Problem:** One size doesn't fit all
**Solution:** Personal calibration during onboarding

### Pitfall 5: Battery Drain
**Problem:** Too frequent sensor sampling
**Solution:** 5-second intervals (0.2 Hz), not continuous

### Pitfall 6: Landscape Mode Confusion
**Problem:** Video watching shows as poor posture
**Solution:** Detect landscape, use adjusted thresholds

---

## Technical Architecture

### Data Flow

```
1. CMMotionManager (iOS Native)
   ‚Üì (every 5 seconds)
2. Platform Channel
   ‚Üì (stream)
3. Flutter Motion Service
   ‚Üì (process)
4. Angle Calculation (pitch + roll ‚Üí tilt)
   ‚Üì
5. Moving Average Filter
   ‚Üì
6. Outlier Rejection
   ‚Üì
7. Threshold Comparison
   ‚Üì
8. Posture State (Good/Fair/Poor)
   ‚Üì
9. Update UI + Character
   ‚Üì
10. Save to Database (every 60 seconds)
```

### Key Classes to Implement

**Flutter Side:**
```
MotionService:
  - Manages platform channel
  - Receives sensor data stream
  - Applies filtering algorithms
  - Calculates posture state
  - Notifies UI of changes

PostureCalculator:
  - Converts pitch/roll to tilt angle
  - Applies moving average
  - Compares against thresholds
  - Returns posture state

FilterService:
  - Moving average buffer
  - Outlier rejection logic
  - Context detection

CalibrationService:
  - Manages personal thresholds
  - Handles calibration flow
  - Stores user preferences
```

**iOS Native Side:**
```
MotionManager:
  - Wraps CMMotionManager
  - Starts/stops device motion updates
  - Streams attitude data to Flutter
  - Handles sensor availability checks

MotionChannel:
  - MethodChannel implementation
  - Bridges Swift/Objective-C to Flutter
  - Handles start/stop commands
  - Sends sensor data stream
```

---

## Appendix: Reference Values

### Typical Angle Ranges by Activity

```
Phone perfectly vertical: 0-5¬∞
Excellent reading posture (eye level): 5-10¬∞
Good reading posture: 11-20¬∞
Typical casual usage: 21-40¬∞
Poor posture (phone getting low): 41-65¬∞
Severe hunch: 66-85¬∞
Phone horizontal (on table): 85-95¬∞
```

### Posture Zone Defaults (5-Tier System)

```
Excellent zone: 0-10¬∞    (Score: 95-100)
Good zone: 11-20¬∞        (Score: 80-94)
Okay zone: 21-40¬∞        (Score: 55-79)
Bad zone: 41-65¬∞         (Score: 25-54)
Poor zone: 66¬∞+          (Score: 0-24)

Alert triggers:
  - Bad zone (41-65¬∞): Gentle haptic after 20 minutes sustained
  - Poor zone (66¬∞+): Immediate haptic alert
  
Moving average: 5 readings
Temporal threshold: 5 seconds (ignore brief angles)
```

### Recommended Sampling Rates

```
CMDeviceMotion update interval: 0.2 seconds (5 Hz)
UI update frequency: 30 seconds
Database save frequency: 60 seconds
Context check frequency: 30 seconds
```

---

## Summary: Key Takeaways

1. **Use CMDeviceMotion, not raw gyroscope** - Single biggest accuracy improvement
2. **Calculate 3D tilt angle** - Don't just use pitch, combine pitch + roll
3. **Universal 5-tier zones** - Excellent (0-10¬∞), Good (11-20¬∞), Okay (21-40¬∞), Bad (41-65¬∞), Poor (66¬∞+)
4. **No personal calibration** - Everyone on same standard for fair social features
5. **Point-based scoring** - Excellent +5pts/min, Good +3pts/min, Okay +1pt/min, Bad/Poor 0pts
6. **Apply moving average** - Smooth out noise for stable readings
7. **Filter temporal noise** - Only count sustained poor posture (>5 seconds)
8. **Detect context** - Auto-pause for face-down, landscape, charging
9. **Test on real devices** - Simulators don't have motion sensors
10. **Optimize for battery** - 5-second sampling is sweet spot
11. **85-90% accuracy is achievable** - Without camera, AirPods, or excessive complexity
12. **Ship MVP first** - Validate concept before over-engineering

---

**Implementation Priority:**
Week 3-4: CMDeviceMotion + 3D tilt + universal zones + filtering + context = 85% accuracy ‚úÖ (SUFFICIENT FOR MVP)
Week 5-6: + Point scoring system + temporal smoothing = 90% accuracy (NICE POLISH)
Week 7-8: + Trajectory analysis + polish = 92% accuracy (DIMINISHING RETURNS)

**Document Version:** 2.0
**Status:** Ready for Implementation
**Target Accuracy:** 85-90% for MVP
**Scoring:** Universal zones + point-based system
